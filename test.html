<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GÃ¶rÃ¼ntÃ¼ Ä°ÅŸleme & Python Dev Quiz ArÅŸivi</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --container-bg: #ffffff;
            --text-color: #333333;
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --error-color: #c0392b;
            --hover-bg: #ecf0f1;
            --border-color: #bdc3c7;
        }

        body.dark-mode {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --primary-color: #ecf0f1;
            --accent-color: #2980b9;
            --hover-bg: #2c2c2c;
            --border-color: #444;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            transition: background-color 0.3s, color 0.3s;
        }

        .quiz-container {
            background-color: var(--container-bg);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 700px;
            padding: 40px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Scrollbar styling */
        .quiz-container::-webkit-scrollbar {
            width: 8px;
        }
        .quiz-container::-webkit-scrollbar-track {
            background: transparent;
        }
        .quiz-container::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 4px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

        .toggle-btn {
            background: transparent;
            border: 2px solid var(--text-color);
            color: var(--text-color);
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: 0.3s;
        }

        .toggle-btn:hover {
            background-color: var(--text-color);
            color: var(--container-bg);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--border-color);
            border-radius: 4px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        .question {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .options-list {
            list-style: none;
            padding: 0;
        }

        .option-item {
            background-color: transparent;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            font-size: 1rem;
        }

        .option-item:hover {
            background-color: var(--hover-bg);
            border-color: var(--accent-color);
        }

        .option-item.selected {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .option-item.correct {
            background-color: var(--success-color) !important;
            border-color: var(--success-color) !important;
            color: white !important;
        }

        .option-item.wrong {
            background-color: var(--error-color) !important;
            border-color: var(--error-color) !important;
            color: white !important;
        }

        .btn-container {
            margin-top: 30px;
            display: flex;
            justify-content: flex-end;
        }

        .action-btn {
            padding: 14px 35px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: 0.3s;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }

        /* Result Screen */
        .result-screen {
            text-align: center;
            display: none;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .score-circle {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: conic-gradient(var(--accent-color) 0%, var(--border-color) 0);
            margin: 0 auto 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            font-weight: bold;
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .score-circle::before {
            content: "";
            position: absolute;
            width: 150px;
            height: 150px;
            background-color: var(--container-bg);
            border-radius: 50%;
        }

        .score-text {
            position: relative;
            z-index: 1;
            color: var(--text-color);
        }

        .result-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 30px 0;
            text-align: center;
        }

        .stat-box {
            padding: 15px;
            background-color: var(--hover-bg);
            border-radius: 10px;
        }

        .stat-label {
            display: block;
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-val {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .retry-btn {
            background-color: var(--error-color);
            margin-left: 10px;
            display: inline-block;
        }

        .restart-btn {
            background-color: var(--text-color);
            display: inline-block;
        }
    </style>
</head>
<body>

    <div class="quiz-container">
        <div class="header" style="align-items: center;">
            <span id="question-counter" style="font-weight: 600; white-space: nowrap; margin-right: 20px;">Soru 1</span>
            <div class="jump-to-question" style="display: flex; align-items: center; width: 100%; margin-right: 20px;">
                <input type="number" id="question-jump-input" placeholder="Soru No" style="width: 100px; padding: 5px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color);">
                <button id="question-jump-btn" style="padding: 5px 10px; margin-left: 5px; border-radius: 5px; border: none; background-color: var(--accent-color); color: white; cursor: pointer;">Git</button>
            </div>
            <button class="toggle-btn" onclick="toggleDarkMode()">ğŸŒ™ / â˜€ï¸</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>

        <div id="quiz-area">
            <div class="question" id="question-text">YÃ¼kleniyor...</div>
            <ul class="options-list" id="options-list">
                </ul>
            <div class="btn-container" style="justify-content: space-between;">
                <button class="action-btn" id="prev-btn" onclick="previousQuestion()" style="background-color: #7f8c8d;">â¬… Ã–nceki</button>
                <div>
                    <button class="action-btn" id="check-btn" onclick="checkAnswer()">Kontrol Et</button>
                    <button class="action-btn" id="next-btn" onclick="nextQuestion()">Sonraki Soru â”</button>
                </div>
            </div>
        </div>

        <div id="result-area" class="result-screen">
            <h2 style="margin-bottom:30px;">Test TamamlandÄ±!</h2>
            
            <div class="score-circle" id="score-circle">
                <span class="score-text" id="final-score">0%</span>
            </div>
            
            <p id="feedback-text" style="font-size:1.1rem; margin-bottom:20px;"></p>
            
            <div class="result-details">
                <div class="stat-box">
                    <span class="stat-label">DoÄŸru SayÄ±sÄ±</span>
                    <span class="stat-val" style="color: var(--success-color);" id="total-correct">0</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">YanlÄ±ÅŸ SayÄ±sÄ±</span>
                    <span class="stat-val" style="color: var(--error-color);" id="total-wrong">0</span>
                </div>
            </div>

            <button class="action-btn restart-btn" onclick="restartFullQuiz()">TÃ¼mÃ¼nÃ¼ Tekrarla</button>
            <button class="action-btn retry-btn" id="retry-wrong-btn" onclick="retryWrongAnswers()">HatalÄ±larÄ± Ã‡Ã¶z</button>
        </div>
    </div>

    <script>
        // --- SORU HAVUZU (TÃœM SORULAR) ---
        // PDF'deki tÃ¼m sorular ve teknik olarak doÄŸru cevaplarÄ± buraya iÅŸlendi.
        const fullQuestionPool = [
            { q: "NumPy dizisinde veri tipini deÄŸiÅŸtirmek iÃ§in hangi metot kullanÄ±lÄ±r?", options: ["img.convert()", "img.astype()", "img.cast()", "img.changetype()", "img.type()"], correct: 1 },
            { q: "NumPy'da Ã§ok boyutlu bir diziyi tek boyutlu bir dizi haline getirmek iÃ§in hangi metot kullanÄ±lÄ±r?", options: ["img.flat()", "img.flatten()", "img.squeeze()", "img.compress()", "img.linearize()"], correct: 1 },
            { q: "Bir NumPy dizisinin devriÄŸini almak iÃ§in hangi metot kullanÄ±lÄ±r?", options: ["img.transpose()", "img.flip()", "img.rotate()", "img.reverse()", "img.swap()"], correct: 0 },
            { q: "NumPy dizisinde elemanlarÄ± belirli bir deÄŸerle kÄ±rpmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["np.limit()", "np.clip()", "np.trim()", "np.bound()", "np.cut()"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼yÃ¼ NumPy dizisi olarak okumak iÃ§in en yaygÄ±n kullanÄ±lan kÃ¼tÃ¼phane hangisidir?", options: ["Matplotlib", "OpenCV", "Pandas", "Scikit-learn", "TensorFlow"], correct: 1 },
            { q: "Python'da OpenCV kÃ¼tÃ¼phanesi nasÄ±l iÃ§e aktarÄ±lÄ±r?", options: ["import opencv", "import cv2", "import open_cv", "include cv2", "import OpenCV2"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ cv2.imwrite ile kaydederken JPEG sÄ±kÄ±ÅŸtÄ±rma kalitesini %90 olarak ayarlamak iÃ§in hangi parametre kullanÄ±lÄ±r?", options: ["[cv2.IMWRITE_JPEG_QUALITY, 90]", "quality = 90", "compression = 90", "[cv2.JPEG_QUALITY, 0.9]", "cv2.setQuality(90)"], correct: 0 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ diske kaydederken cv2.imwrite dosya formatÄ± neye gÃ¶re belirlenir?", options: ["cv2.imwrite fonksiyonunun ikinci parametresine gÃ¶re", "GÃ¶rÃ¼ntÃ¼nÃ¼n boyutuna gÃ¶re", "GÃ¶rÃ¼ntÃ¼nÃ¼n Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼ne gÃ¶re", "Dosya adÄ±nda kullanÄ±lan uzantÄ±ya gÃ¶re", "YalnÄ±zca PNG formatÄ±nda kaydedilebilir"], correct: 3 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ diske kaydetmek iÃ§in kullanÄ±lan fonksiyon hangisidir?", options: ["cv2.save()", "cv2.imwrite()", "cv2.export()", "cv2.write()", "cv2.dump()"], correct: 1 },
            { q: "cv2.imread('resim.jpg', 0) ne yapar?", options: ["Renkli okur", "Gri tonlamalÄ± okur", "Siyah-beyaz okur", "Transparan okur", "Hata verir"], correct: 1 },
            { q: "cv2.imread fonksiyonu ile bir gÃ¶rÃ¼ntÃ¼ yÃ¼klenirken, gÃ¶rÃ¼ntÃ¼yÃ¼ direkt olarak gri tonlamalÄ± yÃ¼klemek iÃ§in hangi parametre kullanÄ±lÄ±r?", options: ["cv2.IMREAD_COLOR", "cv2.IMREAD_UNCHANGED", "cv2.IMREAD_GRAYSCALE", "cv2.IMREAD_RGB", "cv2.IMREAD_LOAD"], correct: 2 },
            { q: "AÅŸaÄŸÄ±dakilerden hangisi bir gÃ¶rÃ¼ntÃ¼yÃ¼ dosyadan okumak iÃ§in kullanÄ±lÄ±r?", options: ["cv2.loadImage()", "cv2.imread()", "cv2.readImage()", "cv2.openImage()", "cv2.getImage()"], correct: 1 },
            { q: "OpenCV'de resmi gÃ¶stermek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.imshow()", "cv2.display()", "cv2.showimage()", "cv2.plot()", "cv2.view()"], correct: 0 },
            { q: "plt.imshow() fonksiyonu hangi kÃ¼tÃ¼phaneye aittir?", options: ["cv2", "numpy", "matplotlib", "pillow", "skimage"], correct: 2 },
            { q: "plt.imshow(img, cmap='gray') ifadesi ne yapar?", options: ["GÃ¶rÃ¼ntÃ¼yÃ¼ renkli gÃ¶sterir", "GÃ¶rÃ¼ntÃ¼nÃ¼n histogramÄ±nÄ± Ã§izer", "GÃ¶rÃ¼ntÃ¼yÃ¼ gri tonlu olarak gÃ¶sterir", "GÃ¶rÃ¼ntÃ¼yÃ¼ kaydeder", "GÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rÃ¼r"], correct: 2 },
            { q: "Python'da gÃ¶rÃ¼ntÃ¼leri matplotlib ile gÃ¶stermek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["plt.show(img)", "plt.imshow(img)", "plt.display(img)", "plt.image(img)", "plt.showimage(img)"], correct: 1 },
            { q: "OpenCV'de resmi ekranda gÃ¶stermek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.show(img)", "cv2.imshow('window name', img)", "cv2.display(img)", "cv2.showimage(img)", "cv2.view(img)"], correct: 1 },
            { q: "GÃ¶rÃ¼ntÃ¼deki kenarlarÄ± vurgulamak iÃ§in hangi iÅŸlem daha keskin sonuÃ§ verir?", options: ["Gaussian Blur", "MedianBlur", "Laplacian", "BilateralFilter", "Resize"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ yeniden boyutlandÄ±rÄ±rken, En YakÄ±n KomÅŸu interpolasyonu kullanmanÄ±n temel avantajÄ± nedir?", options: ["En yÃ¼ksek gÃ¶rÃ¼ntÃ¼ kalitesini sunmasÄ±", "KenarlarÄ± en yumuÅŸak hale getirmesi", "Ä°ÅŸlem hÄ±zÄ±nÄ±n en yÃ¼ksek olmasÄ±", "Moire desenlerini yok etmesi", "Dosya boyutunu kÃ¼Ã§Ã¼ltmesi"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼ matrisindeki piksel deÄŸerlerini belirli bir aralÄ±ÄŸa Ã¶lÃ§eklemek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.scaleAdd()", "cv2.convertScaleAbs()", "cv2.normalize()", "cv2.remap()", "cv2.resize()"], correct: 2 },
            { q: "cv2.resize fonksiyonunda fx=2 ve fy=2 parametreleri kullanÄ±lÄ±rsa gÃ¶rÃ¼ntÃ¼ boyutu nasÄ±l deÄŸiÅŸir?", options: ["GÃ¶rÃ¼ntÃ¼ yatayda 2 birim kayar", "GÃ¶rÃ¼ntÃ¼ dikeyde 2 birim kayar", "GÃ¶rÃ¼ntÃ¼nÃ¼n hem geniÅŸliÄŸi hem de yÃ¼ksekliÄŸi 2 katÄ±na Ã§Ä±kar", "GÃ¶rÃ¼ntÃ¼ 2x2 boyutuna kÃ¼Ã§Ã¼lÃ¼r", "GÃ¶rÃ¼ntÃ¼ 2 derece dÃ¶ner"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼yÃ¼ yeniden boyutlandÄ±rmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.resize()", "cv2.scale()", "cv2.zoom()", "cv2.stretch()", "cv2.crop"], correct: 0 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ boyutunu orantÄ±lÄ± kÃ¼Ã§Ã¼ltmek iÃ§in hangi parametre kullanÄ±lÄ±r?", options: ["fx ve fy", "width ve height", "scaleX ve scaleY", "resizeRatio", "ratio"], correct: 0 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ normalize etmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX)", "cv2.equalizeHist(img)", "cv2.adjustContrast(img)", "cv2.scale(img)", "cv2.resize(img)"], correct: 0 },
            { q: "cv2.Gaussian Blur (img, (5,5), 0) ne yapar?", options: ["Resmi keskinleÅŸtirir", "Resmi griye Ã§evirir", "Gauss bulanÄ±klaÅŸtÄ±rma uygular", "Resmi dÃ¶ndÃ¼rÃ¼r", "Resmi kaydeder"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki gÃ¼rÃ¼ltÃ¼yÃ¼ azaltmak veya gÃ¶rÃ¼ntÃ¼yÃ¼ yumuÅŸatmak iÃ§in kullanÄ±lan Gauss bulanÄ±klaÅŸtÄ±rma iÅŸlemi hangi fonksiyonla gerÃ§ekleÅŸtirilir?", options: ["cv2.blurGaussian()", "cv2.smooth()", "cv2.GaussianBlur()", "cv2.filterBlur()", "cv2.reduceNoise()"], correct: 2 },
            { q: "AÅŸaÄŸÄ±daki bulanÄ±klaÅŸtÄ±rma filtrelerinden hangisi, bir pikselin yeni deÄŸerini belirlerken Ã§evresindeki piksellerin ortanca deÄŸerini kullanÄ±r?", options: ["Ortalama BulanÄ±klaÅŸtÄ±rma", "Gauss BulanÄ±klaÅŸtÄ±rma", "Medyan BulanÄ±klaÅŸtÄ±rma", "Bilateral Filtre", "Kutu Filtresi"], correct: 2 },
            { q: "Gauss filtresinde cv2.Gaussian Blur kullanÄ±lan sigma deÄŸeri neyi kontrol eder?", options: ["Filtreleme Ã§ekirdeÄŸinin (kernel) boyutunu", "BulanÄ±klaÅŸtÄ±rmanÄ±n gÃ¼cÃ¼nÃ¼ ve etki alanÄ±nÄ±", "GÃ¶rÃ¼ntÃ¼deki renk sayÄ±sÄ±nÄ±", "GÃ¶rÃ¼ntÃ¼nÃ¼n dÃ¶ndÃ¼rme aÃ§Ä±sÄ±nÄ±", "AlgoritmanÄ±n Ã§alÄ±ÅŸma hÄ±zÄ±nÄ±"], correct: 1 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼yÃ¼ bulanÄ±klaÅŸtÄ±rmak iÃ§in hangisi uygundur?", options: ["cv2.blur(img, (5,5))", "cv2.medianBlur(img)", "cv2.GaussianBlur(img, (5,5), 0)", "cv2.bilateralFilter (img, 9, 75, 75)", "Hepsi"], correct: 4 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ medyan filtre ile yumuÅŸatmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.median()", "cv2.medianFilter()", "cv2.medianBlur()", "cv2.smoothMedian()", "cv2.filter2D()"], correct: 2 },
            { q: "cv2.medianBlur fonksiyonunda kullanÄ±lan Ã§ekirdek boyutu parametresi iÃ§in geÃ§erli olan matematiksel kural nedir?", options: ["Herhangi bir pozitif sayÄ± olabilir", "Sadece Ã§ift sayÄ± olmalÄ±dÄ±r (2, 4, 6...)", "1'den bÃ¼yÃ¼k bir tek tamsayÄ± olmalÄ±dÄ±r (3, 5, 7...)", "Negatif bir sayÄ± olmalÄ±dÄ±r", "OndalÄ±klÄ± sayÄ± olabilir"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼ Ä°ÅŸlemede kullanÄ±lan cv2.medianBlur filtresi, Ã¶zellikle hangi tÃ¼r gÃ¼rÃ¼ltÃ¼yÃ¼ temizlemede Ã§ok etkilidir?", options: ["Gauss gÃ¼rÃ¼ltÃ¼sÃ¼nÃ¼", "Tuz ve Biber gÃ¼rÃ¼ltÃ¼sÃ¼nÃ¼", "Frekans gÃ¼rÃ¼ltÃ¼sÃ¼nÃ¼", "Sadece parlaklÄ±k gÃ¼rÃ¼ltÃ¼sÃ¼nÃ¼", "Renk gÃ¼rÃ¼ltÃ¼sÃ¼nÃ¼"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki nesnelerin dÄ±ÅŸ sÄ±nÄ±rlarÄ±nÄ± bulmak iÃ§in kullanÄ±lan fonksiyon hangisidir?", options: ["cv2.findContours()", "cv2.drawContours()", "cv2.HoughLines()", "cv2.matchShapes()", "cv2.cornerHarris()"], correct: 0 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ Ã¼zerinde ÅŸekil tespiti iÃ§in hangi yÃ¶ntem kullanÄ±lÄ±r?", options: ["cv2.findContours()", "cv2.cornerHarris()", "cv2.GaussianBlur()", "cv2.equalizeHist()", "cv2.resize()"], correct: 0 },
            { q: "cv2.HoughLines fonksiyonu gÃ¶rÃ¼ntÃ¼ iÅŸlemede ne amaÃ§la kullanÄ±lÄ±r?", options: ["Daireleri tespit etmek iÃ§in", "DoÄŸrusal Ã§izgileri tespit etmek iÃ§in", "KÃ¶ÅŸeleri bulmak iÃ§in", "YÃ¼z tespiti yapmak iÃ§in", "Arka planÄ± silmek iÃ§in"], correct: 1 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ eÅŸikleme iÅŸlemine tabi tutmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.threshold()", "cv2.binarize()", "cv2.limit()", "cv2.cutoff()", "cv2.segment()"], correct: 0 },
            { q: "cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) ne yapar?", options: ["Resmi bulanÄ±klaÅŸtÄ±rÄ±r", "Resmi griye Ã§evirir", "Ä°kili gÃ¶rÃ¼ntÃ¼ oluÅŸturur", "Resmi dÃ¶ndÃ¼rÃ¼r", "Resmi keskinleÅŸtirir"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki kenarlarÄ± vurgulamak iÃ§in hangi iÅŸlem kullanÄ±lÄ±r?", options: ["Blurring", "Thresholding", "Edge Detection", "Dilation", "Erosion"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼de aÃ§ma (Opening) iÅŸlemi hangi sÄ±rayla uygulanÄ±r?", options: ["GeniÅŸleme -> Erozyon", "Erozyon -> GeniÅŸleme", "Blur -> Threshold", "Threshold -> Erozyon", "Erozyon -> Blur"], correct: 1 },
            { q: "GÃ¶rÃ¼ntÃ¼de kapama (Closing) iÅŸlemi hangi sÄ±rayla uygulanÄ±r?", options: ["GeniÅŸleme -> Erozyon", "Erozyon -> GeniÅŸleme", "Blur -> Threshold", "Threshold -> Erozyon", "Erozyon -> Blur"], correct: 0 },
            { q: "Python'da OpenCV ile bir gÃ¶rÃ¼ntÃ¼de hareket algÄ±lamak iÃ§in hangi yÃ¶ntem yaygÄ±ndÄ±r?", options: ["Background Subtraction", "GaussianBlur", "Histogram Equalization", "Median Filter", "Thresholding"], correct: 0 },
            { q: "OpenCV'de renk eÅŸikleme yapmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.inRange(img, lower, upper)", "cv2.colorThreshold(img)", "cv2.thresholdColor(img)", "cv2.maskColor(img)", "cv2.filterColor(img)"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼deki belirli bir renk aralÄ±ÄŸÄ±nÄ± maskelemek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.threshold()", "cv2.colorMask()", "cv2.inRange()", "cv2.rangeMask()", "cv2.maskColor()"], correct: 2 },
            { q: "cv2.threshold fonksiyonu temel olarak ne amaÃ§la kullanÄ±lÄ±r?", options: ["GÃ¶rÃ¼ntÃ¼yÃ¼ bulanÄ±klaÅŸtÄ±rmak iÃ§in", "GÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rmek iÃ§in", "GÃ¶rÃ¼ntÃ¼yÃ¼ ikili hale getirmek veya eÅŸikleme yapmak iÃ§in", "GÃ¶rÃ¼ntÃ¼nÃ¼n histogramÄ±nÄ± Ã§Ä±karmak iÃ§in", "GÃ¶rÃ¼ntÃ¼deki yÃ¼zleri bulmak iÃ§in"], correct: 2 },
            { q: "cv2.threshold fonksiyonunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ ilk deÄŸer nedir?", options: ["EÅŸiklenmiÅŸ gÃ¶rÃ¼ntÃ¼", "Uygulanan eÅŸik deÄŸeri (ret)", "Piksel sayÄ±sÄ±", "Ortalama deÄŸer", "Histogram"], correct: 1 },
            { q: "cv2.threshold fonksiyonu kaÃ§ deÄŸer dÃ¶ndÃ¼rÃ¼r?", options: ["1", "2", "3", "4", "5"], correct: 1 },
            { q: "cv2.threshold() fonksiyonunun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ ikinci deÄŸer nedir?", options: ["EÅŸik deÄŸeri", "Piksel sayÄ±sÄ±", "EÅŸiklenmiÅŸ gÃ¶rÃ¼ntÃ¼", "Ortalama", "Renk kanalÄ±"], correct: 2 },
            { q: "EÅŸikleme iÅŸleminde threshold deÄŸeri altÄ±nda kalan pikseller genelde ne olur?", options: ["Renkleri deÄŸiÅŸir", "Silinir", "255 yapÄ±lÄ±r", "0 yapÄ±lÄ±r", "Saydam olur"], correct: 3 },
            { q: "Python'da OpenCV ile yÃ¼z algÄ±lamak iÃ§in hangi yÃ¶ntem yaygÄ±ndÄ±r?", options: ["Haar Cascade Classifier", "Canny Edge", "Thresholding", "GaussianBlur", "Histogram Equalization"], correct: 0 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ kanallarÄ±nÄ± ayÄ±rmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.separate()", "cv2.split()", "cv2.divide()", "cv2.extract()", "cv2.decompose()"], correct: 1 },
            { q: "cv2.split fonksiyonu ile ayrÄ±lmÄ±ÅŸ renk kanallarÄ±nÄ± tekrar tek bir renkli gÃ¶rÃ¼ntÃ¼ haline getirmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.combine()", "cv2.join()", "cv2.mixChannels()", "cv2.merge()", "cv2.unite()"], correct: 3 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ aynalama iÅŸlemi iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.mirror", "cv2.flip()", "cv2.reverse", "cv2.reflect()", "cv2.invert()"], correct: 1 },
            { q: "Python'da gÃ¶rÃ¼ntÃ¼yÃ¼ 90 derece saat yÃ¶nÃ¼nde dÃ¶ndÃ¼rmek iÃ§in doÄŸru komut hangisidir?", options: ["cv2.rotate(img, 0)", "cv2.turn(img, 90)", "cv2.flip(img, 90)", "cv2.angle(img, 90)", "cv2.transform(img, 90)"], correct: 0 },
            { q: "np.flip(img, 0) iÅŸlemi ne yapar?", options: ["Yatay Ã§evirme", "Dikey Ã§evirme (x eksenine gÃ¶re)", "DÃ¶ndÃ¼rme", "Maskeleme", "KarÄ±ÅŸtÄ±rma"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼yÃ¼ yatay eksende Ã§evirmek iÃ§in hangi kod kullanÄ±lÄ±r?", options: ["cv2.flip(img, 0)", "cv2.flip(img, 1)", "cv2.flip(img, -1)", "cv2.rotate(img, 90)", "cv2.transpose(img)"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼yÃ¼ yatay ve dikey eksende Ã§evirmek iÃ§in hangi kod kullanÄ±lÄ±r?", options: ["cv2.flip(img, 0)", "cv2.flip(img, 1)", "cv2.flip(img, -1)", "cv2.rotate(img, 90)", "cv2.transpose(img)"], correct: 2 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼ye daire Ã§izmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.circle(img, (x,y), r, color, thickness)", "cv2.drawCircle(img, x, y, r)", "cv2.ellipse(img, (x,y), r)", "cv2.dot(img, (x,y), r)", "cv2.drawEllipse(img, (x,y), r)"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼ Ã¼zerinde bir dikdÃ¶rtgen Ã§izmek iÃ§in kullanÄ±lan fonksiyon hangisidir?", options: ["cv2.circle()", "cv2.ellipse()", "cv2.polylines()", "cv2.rectangle()", "cv2.line()"], correct: 3 },
            { q: "cv2.rectangle veya cv2.circle gibi fonksiyonlarla bir ÅŸekil Ã§izerken, ÅŸeklin iÃ§ini tamamen doldurmak iÃ§in thickness parametresine hangi deÄŸer verilir?", options: ["0", "1", "-1", "100", "cv2.FILLED"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼ Ã¼zerine bir daire Ã§izmek iÃ§in kullanÄ±lan cv2.circle fonksiyonunda zorunlu olarak verilmesi gereken geometrik parametreler hangileridir?", options: ["Merkez koordinatÄ± ve YarÄ±Ã§ap", "Sol Ã¼st kÃ¶ÅŸe ve SaÄŸ alt kÃ¶ÅŸe", "BaÅŸlangÄ±Ã§ noktasÄ± ve BitiÅŸ noktasÄ±", "Ã‡ap ve Ã‡evre", "AÃ§Ä± ve Uzunluk"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼deki daire ÅŸeklindeki nesneleri tespit etmek iÃ§in cv2.HoughCircles fonksiyonu hangi yÃ¶ntemi temel alÄ±r?", options: ["Hough Gradient Method", "K-Nearest Neighbors", "Support Vector Machine", "Fourier Transform", "Laplacian Pyramid"], correct: 0 },
            { q: "cv2.circle veya cv2.line gibi Ã§izim fonksiyonlarÄ±nda, Ã§izginin tÄ±rtÄ±klÄ± gÃ¶rÃ¼nmesini engelleyerek daha pÃ¼rÃ¼zsÃ¼z olmasÄ±nÄ± saÄŸlayan Ã§izgi tipi parametresi hangisidir?", options: ["cv2.LINE_SMOOTH", "cv2.LINE_4", "cv2.LINE_8", "cv2.LINE_AA", "cv2.LINE_HQ"], correct: 3 },
            { q: "cv2.HoughCircles fonksiyonu neyi tespit eder?", options: ["Dikey Ã§izgiler", "Kareler", "Daireler", "ÃœÃ§genler", "Renk geÃ§iÅŸleri"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼deki nesnelerin konumunu ve yÃ¶nÃ¼nÃ¼ belirlemek iÃ§in hangi bilgi kullanÄ±lÄ±r?", options: ["GÃ¶rÃ¼ntÃ¼ histogramÄ±", "GÃ¶rÃ¼ntÃ¼ boyutu", "cv2.moments()", "cv2.threshold()", "cv2.resize"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼ye elips Ã§izmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.ellipse()", "cv2.drawEllipse()", "cv2.plotEllipse()", "cv2.rounded()", "cv2.oval()"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼deki nesneleri sÄ±nÄ±rlayan elipsi bulmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.fitEllipse()", "cv2.drawEllipse()", "cv2.ellipseFit()", "cv2.findEllipse()", "cv2.minEllipse()"], correct: 0 },
            { q: "cv2.rectangle(img, pt1, pt2, color, thickness) fonksiyonunda pt1 ve pt2 parametreleri neyi temsil eder?", options: ["Merkezi koordinatlar", "DikdÃ¶rtgenin sol Ã¼st ve saÄŸ alt kÃ¶ÅŸe koordinatlarÄ±nÄ±", "DikdÃ¶rtgenin geniÅŸliÄŸi ve yÃ¼ksekliÄŸi", "DikdÃ¶rtgenin dÃ¶ndÃ¼rme aÃ§Ä±sÄ±nÄ±", "GÃ¶rÃ¼ntÃ¼nÃ¼n boyutunu"], correct: 1 },
            { q: "GÃ¶rÃ¼ntÃ¼deki nesneleri sÄ±nÄ±rlayan dikdÃ¶rtgeni bulmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.rectangle()", "cv2.boundingBox()", "cv2.minRect()", "cv2.boundingRect()", "cv2.box()"], correct: 3 },
            { q: "GÃ¶rÃ¼ntÃ¼ Ã¼zerinde bir metin yazdÄ±rmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.writeText()", "cv2.drawText()", "cv2.addText()", "cv2.putText()", "cv2.print()"], correct: 3 },
            { q: "OpenCV'de kameradan gÃ¶rÃ¼ntÃ¼ alÄ±rken video yakalama objesi oluÅŸturmak iÃ§in kullanÄ±lan sÄ±nÄ±f hangisidir?", options: ["cv2.Video()", "cv2.Capture()", "cv2.VideoCapture()", "cv2.Camera()", "cv2.Webcam()"], correct: 2 },
            { q: "Bir video dosyasÄ±nÄ± cv2.VideoCapture ile okurken, videonun sonuna gelindiÄŸini cap.read fonksiyonunun dÃ¶nÃ¼ÅŸ deÄŸerleri nasÄ±l olur?", options: ["Fonksiyon hata fÄ±rlatÄ±r", "GÃ¶rÃ¼ntÃ¼ matrisi tamamen siyah olur", "Ä°lk dÃ¶nÃ¼ÅŸ deÄŸeri False, ikinci deÄŸer (frame) None olur", "FPS deÄŸeri 0 olur", "Video otomatik olarak baÅŸa sarar"], correct: 2 },
            { q: "Python'da OpenCV ile video karelerini kaydetmek iÃ§in hangi sÄ±nÄ±f kullanÄ±lÄ±r?", options: ["cv2.VideoWriter", "cv2.VideoCapture", "cv2.VideoSave", "cv2.VideoRecord", "cv2.VideoOutput"], correct: 0 },
            { q: "Bilgisayar kamerasÄ±ndan canlÄ± gÃ¶rÃ¼ntÃ¼ almak iÃ§in hangi sÄ±nÄ±f baÅŸlatÄ±lmalÄ±dÄ±r?", options: ["cv2.Camera()", "cv2.Webcam()", "cv2.VideoCapture(0)", "cv2.Stream()", "cv2.Live()"], correct: 2 },
            { q: "OpenCV ile video akÄ±ÅŸÄ±ndan kareleri almak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cap.read()", "cap.get()", "cv2.readVideo()", "cap.frame()", "cv2.captureFrame()"], correct: 0 },
            { q: "OpenCV ile bir videodan kare alÄ±rken hangi fonksiyon kullanÄ±lÄ±r?", options: ["ret, frame = cap.read()", "frame = cap.get()", "frame = cap.capture()", "frame = cv2.readVideo()", "frame = cap.frame()"], correct: 0 },
            { q: "cv2.VideoWriter kullanÄ±rken karÅŸÄ±laÅŸÄ±lan en yaygÄ±n hata sebebi nedir?", options: ["Dosya isminin kÄ±sa olmasÄ±", "Videonun siyah beyaz olmasÄ±", "cv2.VideoWriter iÃ§ine girilen boyut ile frame boyutunun birebir uyuÅŸmamasÄ±", "FPS deÄŸerinin 30 olmasÄ±", "Python sÃ¼rÃ¼mÃ¼nÃ¼n eski olmasÄ±"], correct: 2 },
            { q: "OpenCV ile video kaydederken FPS parametresi hangi sÄ±radadÄ±r?", options: ["cv2.VideoWriter('output.avi', fourcc, fps, (w,h))", "cv2.VideoWriter('output.avi', fps, fourcc, (w,h))", "cv2.VideoWriter('output.avi', (w,h), fps, fourcc)", "cv2.VideoWriter('output.avi', fourcc, (w,h), fps)", "cv2.VideoWriter('output.avi', fps, (w,h), fourcc)"], correct: 0 },
            { q: "cv2.waitKey(0) komutunun iÅŸlevi nedir?", options: ["ProgramÄ± 0 milisaniye bekletir ve kapatÄ±r", "Sadece '0' tuÅŸuna basÄ±lmasÄ±nÄ± bekler", "Bir tuÅŸa basÄ±lana kadar pencereyi aÃ§Ä±k tutar", "GÃ¶rÃ¼ntÃ¼yÃ¼ 0 derece dÃ¶ndÃ¼rÃ¼r", "Videoyu baÅŸa sarar"], correct: 2 },
            { q: "Video iÅŸleme bittiÄŸinde, kamerayÄ± veya video dosyasÄ±nÄ± serbest bÄ±rakmak iÃ§in hangi metot Ã§aÄŸrÄ±lmalÄ±dÄ±r?", options: ["cap.close()", "cap.stop()", "cap.delete()", "cap.release()", "cap.end()"], correct: 3 },
            { q: "Bir video dosyasÄ±nÄ±n belirli bir milisaniyesine doÄŸrudan gitmek iÃ§in cap.set fonksiyonuna hangi Ã¶zellik verilmelidir?", options: ["cv2.CAP_PROP_POS_MSEC", "cv2.CAP_PROP_FPS", "cv2.CAP_PROP_FRAME_WIDTH", "cv2.CAP_PROP_FORMAT", "cv2.CAP_PROP_FOURCC"], correct: 0 },
            { q: "Temel BileÅŸenler Analizi (PCA), gÃ¶rÃ¼ntÃ¼ iÅŸlemede genellikle ne amaÃ§la kullanÄ±lÄ±r?", options: ["GÃ¶rÃ¼ntÃ¼yÃ¼ bulanÄ±klaÅŸtÄ±rmak iÃ§in", "GÃ¶rÃ¼ntÃ¼nÃ¼n boyutunu artÄ±rmak iÃ§in", "Nesnenin yÃ¶nelimini bulmak ve boyut indirgemek iÃ§in", "Renk doygunluÄŸunu artÄ±rmak iÃ§in", "Video kaydetmek iÃ§in"], correct: 2 },
            { q: "Bir videonun FPS deÄŸerini Ã¶ÄŸrenmek iÃ§in cap.get fonksiyonuna hangi Ã¶zellik kodu verilmelidir?", options: ["cv2.CAP_PROP_FRAME_WIDTH", "cv2.CAP_PROP_POS_MSEC", "cv2.CAP_PROP_FPS", "cv2.CAP_PROP_FRAME_COUNT", "cv2.CAP_PROP_FOURCC"], correct: 2 },
            { q: "OpenCV'de video akÄ±ÅŸÄ± sÄ±rasÄ±nda pencereyi kapatmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.destroyAllWindows()", "cv2.closeWindows()", "cv2.endVideo()", "cv2.stopVideo()", "cv2.quit()"], correct: 0 },
            { q: "OpenCV ile video kaydÄ± baÅŸlatÄ±rken FPS parametresi neyi belirler?", options: ["Saniyedeki kare sayÄ±sÄ±nÄ±", "Video codec", "Boyut", "Renk formatÄ±", "Kare sayÄ±sÄ±"], correct: 0 },
            { q: "Histogram eÅŸitleme iÅŸlemi genellikle hangi tip gÃ¶rÃ¼ntÃ¼lerde daha etkili sonuÃ§ verir?", options: ["YÃ¼ksek kontrastlÄ± gÃ¶rÃ¼ntÃ¼lerde", "Ã‡ok aydÄ±nlÄ±k veya Ã§ok karanlÄ±k (dÃ¼ÅŸÃ¼k kontrastlÄ±) gÃ¶rÃ¼ntÃ¼lerde", "Zaten mÃ¼kemmel kontrasta sahip gÃ¶rÃ¼ntÃ¼lerde", "Sadece renkli gÃ¶rÃ¼ntÃ¼lerde", "Sadece video akÄ±ÅŸlarÄ±nda"], correct: 1 },
            { q: "Histogram eÅŸitleme iÅŸlemi gÃ¶rÃ¼ntÃ¼de ne saÄŸlar?", options: ["GÃ¼rÃ¼ltÃ¼yÃ¼ artÄ±rÄ±r", "Renkleri deÄŸiÅŸtirir", "KontrastÄ± artÄ±rÄ±r", "GÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rÃ¼r", "GÃ¶rÃ¼ntÃ¼yÃ¼ kÄ±rpar"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki piksellerin yoÄŸunluk daÄŸÄ±lÄ±mÄ±nÄ± gÃ¶steren grafiÄŸe ne ad verilir?", options: ["Spektrogram", "Histogram", "Osilogram", "Radyogram", "Scatter Plot"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n histogramÄ±nÄ± hesaplamak iÃ§in cv2.calcHist fonksiyonu kullanÄ±lÄ±rken, images parametresi neden kÃ¶ÅŸeli parantez iÃ§inde [img] olarak verilir?", options: ["Ã‡Ã¼nkÃ¼ fonksiyon her zaman bir liste bekler", "YanlÄ±ÅŸlÄ±kla birden fazla resim verilmesin diye", "NumPy dizisi olduÄŸu iÃ§in", "Renkli gÃ¶rÃ¼ntÃ¼ olduÄŸu iÃ§in", "Bu bir yazÄ±m hatasÄ±dÄ±r, parantez gerekmez"], correct: 0 },
            { q: "cv2.calcHist() fonksiyonunda maske parametresi None olarak verilirse hesaplama nasÄ±l yapÄ±lÄ±r?", options: ["GÃ¶rÃ¼ntÃ¼nÃ¼n sadece orta kÄ±smÄ± iÃ§in histogram hesaplanÄ±r", "GÃ¶rÃ¼ntÃ¼nÃ¼n tamamÄ± iÃ§in histogram hesaplanÄ±r", "Histogram hesaplanmaz, hata dÃ¶ner", "GÃ¶rÃ¼ntÃ¼ gri tonlamaya Ã§evrilir", "Rastgele bir bÃ¶lge seÃ§ilir"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n histogramÄ±nÄ± hesaplamak iÃ§in hangi OpenCV fonksiyonu kullanÄ±lÄ±r?", options: ["cv2.histImage()", "cv2.calcHistogram()", "cv2.calcHist()", "cv2.imageHist()", "cv2.histCalc()"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n histogramÄ±nÄ± hesaplamak temel olarak neyi gÃ¶sterir?", options: ["GÃ¶rÃ¼ntÃ¼deki nesnelerin ÅŸeklini", "GÃ¶rÃ¼ntÃ¼deki her bir piksel deÄŸerinin ne kadar sÄ±klÄ±kta bulunduÄŸu", "GÃ¶rÃ¼ntÃ¼deki renk tonlarÄ±nÄ±n ortalamasÄ±nÄ±", "GÃ¶rÃ¼ntÃ¼nÃ¼n dosya boyutunu", "GÃ¶rÃ¼ntÃ¼nÃ¼n Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼nÃ¼"], correct: 1 },
            { q: "plt.title('Resim') fonksiyonu ne iÅŸe yarar?", options: ["GÃ¶rÃ¼ntÃ¼yÃ¼ kaydeder", "GÃ¶rÃ¼ntÃ¼ye baÅŸlÄ±k ekler", "GÃ¶rÃ¼ntÃ¼yÃ¼ gri yapar", "GÃ¶rÃ¼ntÃ¼yÃ¼ bÃ¼yÃ¼tÃ¼r", "Histogram Ã§izer"], correct: 1 },
            { q: "AÅŸaÄŸÄ±dakilerden hangisi gÃ¶rÃ¼ntÃ¼ gÃ¼rÃ¼ltÃ¼sÃ¼ tÃ¼rlerinden biri deÄŸildir?", options: ["Gaussian noise", "Salt & Pepper noise", "Speckle noise", "Histogram noise", "Poisson noise"], correct: 3 },
            { q: "img.dtype ifadesi bir gÃ¶rÃ¼ntÃ¼ hakkÄ±nda neyi verir?", options: ["Piksel toplamÄ±nÄ±", "GÃ¶rÃ¼ntÃ¼nÃ¼n geniÅŸliÄŸini", "Veri tipini", "Kanal sayÄ±sÄ±nÄ±", "Histogram tÃ¼rÃ¼nÃ¼"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki piksel deÄŸerlerini normalize etmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.normalize()", "cv2.equalizeHist()", "cv2.scale()", "cv2.adjust()", "cv2.balance()"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼ histogramÄ± eÅŸitleme iÅŸlemi renkli gÃ¶rÃ¼ntÃ¼de uygulanacaksa Ã¶nce ne yapÄ±lmalÄ±dÄ±r?", options: ["Renk uzayÄ± deÄŸiÅŸtirilir (Ã¶rn: RGB -> YUV/HSV)", "GÃ¶rÃ¼ntÃ¼ dÃ¶ndÃ¼rÃ¼lÃ¼r", "GÃ¶rÃ¼ntÃ¼ kÄ±rpÄ±lÄ±r", "GÃ¶rÃ¼ntÃ¼ boyutlandÄ±rÄ±lÄ±r", "GÃ¶rÃ¼ntÃ¼ kaydedilir"], correct: 0 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ Ã¼zerinde median blur uygulamanÄ±n amacÄ± nedir?", options: ["GÃ¼rÃ¼ltÃ¼yÃ¼ azaltmak", "KenarlarÄ± keskinleÅŸtirmek", "Histogram eÅŸitlemek", "Renkleri deÄŸiÅŸtirmek", "Kontrast artÄ±rmak"], correct: 0 },
            { q: "OpenCV ile yÃ¼z tespiti sonrasÄ± hangi iÅŸlem genellikle yapÄ±lÄ±r?", options: ["DikdÃ¶rtgen Ã§izmek", "Gaussian blur uygulamak", "Kenar algÄ±lamak", "Histogram eÅŸitlemek", "Renk uzayÄ±nÄ± deÄŸiÅŸtirmek"], correct: 0 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ Gaussian blur ile bulanÄ±klaÅŸtÄ±rÄ±rken hangi parametre zorunludur?", options: ["Kernel boyutu", "Renk kanalÄ±", "Sigma", "Histogram", "Boyut"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼ histogramÄ± eÅŸitleme iÅŸlemi renkli gÃ¶rÃ¼ntÃ¼de hangi renk uzayÄ±nda yapÄ±labilir?", options: ["RGB", "HSV (Value kanalÄ±)", "LAB", "BGR", "CMYK"], correct: 1 },
            { q: "Python'da gÃ¶rÃ¼ntÃ¼ histogramÄ± Ã§izmek iÃ§in hangi kÃ¼tÃ¼phane kullanÄ±lÄ±r?", options: ["pandas", "seaborn", "matplotlib", "flask", "tkinter"], correct: 2 },
            { q: "Python ile gÃ¶rÃ¼ntÃ¼ iÅŸleme sÄ±rasÄ±nda performansÄ± artÄ±rmak iÃ§in numpy ile birlikte hangi kÃ¼tÃ¼phane kullanÄ±labilir?", options: ["math", "pandas", "numba", "scipy", "matplotlib"], correct: 2 },
            { q: "HSV renk uzayÄ±ndaki 'H' harfi neyi temsil eder?", options: ["Height", "Hue (Renk Tonu)", "High", "Heat", "Histogram"], correct: 1 },
            { q: "cv2.equalizeHist fonksiyonu hangi tÃ¼r gÃ¶rÃ¼ntÃ¼lerde Ã§alÄ±ÅŸÄ±r?", options: ["RGB gÃ¶rÃ¼ntÃ¼ler", "HSV gÃ¶rÃ¼ntÃ¼ler", "Tek kanallÄ± (gri tonlamalÄ±) gÃ¶rÃ¼ntÃ¼ler", "16-bit gÃ¶rÃ¼ntÃ¼ler", "Renkli PNG gÃ¶rÃ¼ntÃ¼ler"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼ histogramÄ± Ã§iziminde hangi renk kanalÄ± iÃ§in histogram alÄ±nabilir?", options: ["Sadece gri", "Sadece RGB", "Her kanal ayrÄ± ayrÄ±", "Sadece HSV", "Sadece LAB"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼ histogramÄ± eÅŸitleme iÅŸlemi hangi gÃ¶rÃ¼ntÃ¼ tÃ¼rÃ¼nde daha etkilidir?", options: ["Renkli", "Gri tonlamalÄ±", "HSV", "LAB", "RGB"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n kontrastÄ±nÄ± histogram eÅŸitleme yÃ¶ntemiyle artÄ±rmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.increaseContrast()", "cv2.histEqual()", "cv2.normalize()", "cv2.equalizeHist()", "cv2.stretch()"], correct: 3 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n histogramÄ±nÄ±n geniÅŸ olmasÄ± neyi gÃ¶sterir?", options: ["Renk bozulmasÄ±", "DÃ¼ÅŸÃ¼k kontrast", "YÃ¼ksek kontrast", "GÃ¼rÃ¼ltÃ¼ miktarÄ±", "Gamma deÄŸeri"], correct: 2 },
            { q: "Histogram eÅŸitleme iÅŸleminden sonra gÃ¶rÃ¼ntÃ¼nÃ¼n genellikle nasÄ±l deÄŸiÅŸtiÄŸi sÃ¶ylenebilir?", options: ["Daha gÃ¼rÃ¼ltÃ¼lÃ¼ olur", "Daha karanlÄ±k olur", "KontrastÄ± artar", "Kanal sayÄ±sÄ± artar", "Ã‡Ã¶zÃ¼nÃ¼rlÃ¼k artar"], correct: 2 },
            { q: "Ä°ki histogramÄ±n birbirine ne kadar benzediÄŸini kÄ±yaslamak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.matchHist()", "cv2.histDiff()", "cv2.compareHist()", "cv2.checkHist()", "cv2.calcHistDiff()"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n kopyasÄ±nÄ± oluÅŸturmak iÃ§in hangi metot kullanÄ±lÄ±r?", options: ["img.copy", "img.copy()", "img.duplicate()", "copy(img)", "img.replicate()"], correct: 1 },
            { q: "Ä°ki gÃ¶rÃ¼ntÃ¼yÃ¼ dikey olarak birleÅŸtirmek iÃ§in NumPy'de hangi ifade kullanÄ±lÄ±r?", options: ["np.merge(img1, img2)", "np.concatenate((img1, img2), axis=0)", "np.append(img1, img2)", "np.add(img1, img2)", "np.vstack((img1, img2))"], correct: 4 },
            { q: "OpenCV'de iki gÃ¶rÃ¼ntÃ¼yÃ¼ Ã¼st Ã¼ste bindirmek (blend) iÃ§in hangi fonksiyon uygundur?", options: ["cv2.addWeighted(img1, alpha, img2, beta, gamma)", "cv2.overlay(img1, img2)", "np.hstack([img1, img2])", "cv2.merge(img1, img2)", "cv2.blend(img1, img2)"], correct: 0 },
            { q: "Ä°ki gÃ¶rÃ¼ntÃ¼yÃ¼ toplarken cv2.add fonksiyonu kullanmak ile standart + operatÃ¶rÃ¼ kullanmak arasÄ±ndaki fark nedir?", options: ["Fark yoktur", "cv2.add() doygunluÄŸa bakar (255'i geÃ§emez), + operatÃ¶rÃ¼ mod alma iÅŸlemi yapar", "cv2.add() sadece gri tonlamalÄ± resimlerde Ã§alÄ±ÅŸÄ±r", "+ operatÃ¶rÃ¼ daha yavaÅŸtÄ±r", "cv2.add() gÃ¶rÃ¼ntÃ¼leri otomatik olarak yeniden boyutlandÄ±rÄ±r"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼de, kÃ¼Ã§Ã¼k beyaz gÃ¼rÃ¼ltÃ¼ noktalarÄ±nÄ± silmek ve konturlarÄ± yumuÅŸatmak iÃ§in hangi morfolojik iÅŸlem kombinasyonu kullanÄ±lÄ±r?", options: ["Kapanma", "AÃ§Ä±lma (Opening)", "Morfolojik Gradyan", "Top Hat", "GeniÅŸletme"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki konturlarÄ±n ÅŸekil benzerliÄŸini karÅŸÄ±laÅŸtÄ±rmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.matchShapes()", "cv2.compareContours()", "cv2.shapeMatch()", "cv2.contourCompare()", "cv2.similarity()"], correct: 0 },
            { q: "img.shape ifadesi bir gÃ¶rÃ¼ntÃ¼ iÃ§in neyi verir?", options: ["Piksel toplamÄ±nÄ±", "Dosya boyutunu", "YÃ¼kseklik, geniÅŸlik ve kanal sayÄ±sÄ±nÄ±", "DPI deÄŸerini", "Renk histogramÄ±nÄ±"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n kanal sayÄ±sÄ±nÄ± Ã¶ÄŸrenmek iÃ§in hangi ifade doÄŸrudur?", options: ["img.channel", "img.channels()", "img.shape[0]", "img.shape[2]", "img.get(2)"], correct: 3 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼yÃ¼ bulanÄ±klaÅŸtÄ±rmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.blur()", "cv2.sharp()", "cv2.smooth()", "cv2.noise()", "cv2.clean()"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼ Ã¼zerindeki tuz-biber gÃ¼rÃ¼ltÃ¼sÃ¼nÃ¼ gidermek iÃ§in en etkili bulanÄ±klaÅŸtÄ±rma yÃ¶ntemi hangisidir?", options: ["Gaussian Blur", "Mean Blur", "Median Blur", "Bilateral Filter", "Box Filter"], correct: 2 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ Ã¼zerinde kenarlarÄ± belirginleÅŸtirmek iÃ§in hangi filtre yaygÄ±n kullanÄ±lÄ±r?", options: ["Laplacian", "Median", "Gaussian", "Blur", "Bilateral"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼deki kenarlarÄ± bulmak iÃ§in kullanÄ±lan Laplacian operatÃ¶rÃ¼ hangi tÃ¼reve dayanÄ±r?", options: ["0. tÃ¼rev", "1. tÃ¼rev", "2. tÃ¼rev", "3. tÃ¼rev", "4. tÃ¼rev"], correct: 2 },
            { q: "cv2.Laplacian() fonksiyonu hangi tÃ¼r kenarlarÄ± vurgular?", options: ["YalnÄ±zca yatay", "YalnÄ±zca dikey", "Hem yatay hem dikey", "Sadece eÄŸik", "Sadece kÃ¶ÅŸe"], correct: 2 },
            { q: "OpenCV'de kenar tespiti yapmak iÃ§in kullanÄ±lan fonksiyon hangisidir?", options: ["cv2.edge()", "cv2.findEdge()", "cv2.Canny()", "cv2.detect()", "cv2.sharp()"], correct: 2 },
            { q: "cv2.Canny fonksiyonunda kullanÄ±lan eÅŸik deÄŸerleri neyi belirler?", options: ["Kernel boyutunu", "Renk dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼", "Kenar hassasiyetini (Hysteresis Thresholding)", "GÃ¼rÃ¼ltÃ¼ dÃ¼zeyini", "Histogram Ã§Ã¶zÃ¼nÃ¼rlÃ¼ÄŸÃ¼nÃ¼"], correct: 2 },
            { q: "OpenCV'de okunan standart bir BGR gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼n sadece Mavi kanalÄ±na eriÅŸmek iÃ§in aÅŸaÄŸÄ±daki NumPy dilimlemesi hangisidir?", options: ["img[:, :, 0]", "img[:, :, 1]", "img[:, :, 2]", "img[0, :, :]", "img[-1]"], correct: 0 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki tÃ¼m piksellerin deÄŸerini sÄ±fÄ±rlamak iÃ§in hangi iÅŸlem yapÄ±lÄ±r?", options: ["img=255", "img[:] = 0", "img.clear()", "img = None", "img = []"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki tÃ¼m pikselleri beyaz yapmak iÃ§in hangi kod kullanÄ±lÄ±r?", options: ["img[:] = 255", "img[:] = 0", "img[:] = -1", "img[:] = True", "img[:] = 128"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼deki tÃ¼m pikselleri ters Ã§evirmek iÃ§in hangi iÅŸlem yapÄ±lÄ±r?", options: ["255 - img", "img * -1", "img[::-1]", "img.not()", "img.invert()"], correct: 0 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ x ekseninde 50, y ekseninde 100 piksel kaydÄ±rmak iÃ§in oluÅŸturulmasÄ± gereken 2x3'lÃ¼k dÃ¶nÃ¼ÅŸÃ¼m matrisi aÅŸaÄŸÄ±dakilerden hangisidir?", options: ["[[1, 0, 100], [0, 1, 50]]", "[[1, 0, 50], [0, 1, 100]]", "[[0, 1, 50], [1, 0, 100]]", "[[50, 0, 1], [100, 1, 0]]", "[[1, 1, 50], [1, 1, 100]]"], correct: 1 },
            { q: "GÃ¶rÃ¼ntÃ¼de ROI seÃ§imi sonrasÄ± seÃ§ilen alanÄ± almak iÃ§in hangisi kullanÄ±lÄ±r?", options: ["roi = img[roi]", "roi = img[y:y+h, x:x+w]", "roi = img[x:x+w, y:y+h]", "roi = img.crop(x, y, w, h)", "roi = img.select(x, y, w, h)"], correct: 1 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ Ã¼zerinde piksel deÄŸerini deÄŸiÅŸtirmek iÃ§in hangi yÃ¶ntem kullanÄ±lÄ±r?", options: ["img[y, x] = [b,g,r]", "cv2.setPixel(img, x, y, color)", "cv2.modify(img, x, y)", "img.setPixel(x, y, color)", "cv2.changePixel(img, x, y)"], correct: 0 },
            { q: "OpenCV'de piksel deÄŸerine eriÅŸmek iÃ§in hangi yapÄ± kullanÄ±lÄ±r?", options: ["img.value()", "img[x][y]", "img[y, x]", "img.pixel(x,y)", "img.color(x,y)"], correct: 2 },
            { q: "Matplotlib ile gÃ¶rÃ¼ntÃ¼ gÃ¶sterirken renklerin ters gÃ¶rÃ¼nmesinin nedeni nedir?", options: ["GÃ¶rÃ¼ntÃ¼ bozuk yÃ¼klenmiÅŸtir", "Matplotlib renklerin alpha kanalÄ±nÄ± okumaz", "Matplotlib'in RGB, OpenCV'nin BGR formatÄ± kullanmasÄ±", "Ã‡Ã¶zÃ¼nÃ¼rlÃ¼k uyumsuzluÄŸu vardÄ±r", "NumPy dizisi hatalÄ±dÄ±r"], correct: 2 },
            { q: "OpenCV varsayÄ±lan olarak renkli gÃ¶rÃ¼ntÃ¼leri hangi renk uzayÄ±nda okur?", options: ["RGB", "HSV", "CMYK", "BGR", "HSL"], correct: 3 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki nesnelerin renk tonuna, doygunluÄŸuna ve parlaklÄ±ÄŸÄ±na gÃ¶re daha kolay ayrÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in hangi renk uzayÄ± tercih edilir?", options: ["RGB", "BGR", "HSV", "CMYK", "LAB"], correct: 2 },
            { q: "YÃ¼z tanÄ±ma veya obje takibi projelerinde sÄ±klÄ±kla kullanÄ±lan, gÃ¶rÃ¼ntÃ¼nÃ¼n parlaklÄ±k bilgisini renk bilgisinden ayÄ±ran renk uzayÄ± hangisidir?", options: ["BGR", "RGB", "YCrCb (veya HSV)", "GRAY", "Binary"], correct: 2 },
            { q: "RGB renk uzayÄ±ndan farklÄ± olarak YCbCr renk uzayÄ±nÄ±n temel avantajÄ± nedir?", options: ["Daha fazla renk iÃ§ermesi", "ParlaklÄ±k bilgisinin renkten ayrÄ±lmÄ±ÅŸ olmasÄ±", "Sadece kÄ±rmÄ±zÄ± rengi barÄ±ndÄ±rmasÄ±", "Python'da daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±", "Matplotlib ile doÄŸrudan uyumlu olmasÄ±"], correct: 1 },
            { q: "HSV renk uzayÄ±nda, gÃ¶rÃ¼ntÃ¼nÃ¼n ne kadar canlÄ± veya donuk olduÄŸunu yani rengin saflÄ±ÄŸÄ±nÄ± belirleyen bileÅŸen hangisidir?", options: ["Hue (Ton)", "Saturation (Doygunluk)", "Value (ParlaklÄ±k)", "Lightness", "Intensity"], correct: 1 },
            { q: "640x480 boyutunda, siyah renkte ve renkli formatta bir gÃ¶rÃ¼ntÃ¼ oluÅŸturmak iÃ§in doÄŸru komutu hangisidir?", options: ["np.zeros((480, 640, 3), dtype=np.uint8)", "np.zeros((640, 480, 3), dtype=np.uint8)", "np.ones((480, 640, 3), dtype=np.uint8)", "np.empty((480, 640), dtype=np.float)", "cv2.createBlackImage(640, 480)"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼ Ã¼zerindeki bir nokta kÃ¼mesine en iyi uyan doÄŸruyu bulmak iÃ§in kullanÄ±lan fonksiyon hangisidir?", options: ["cv2.fitLine()", "cv2.drawLine()", "cv2.bestLine()", "cv2.polyFit()", "cv2.linearReg()"], correct: 0 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki nesneleri sÄ±nÄ±rlayan kutuyu Ã§izmek iÃ§in hangi bilgi gereklidir?", options: ["Kontur alanÄ±", "GÃ¶rÃ¼ntÃ¼ boyutu", "DikdÃ¶rtgen koordinatlarÄ± (x,y,w,h)", "Histogram verisi", "Piksel yoÄŸunluÄŸu"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki konturlarÄ±n iÃ§ini doldurmak iÃ§in hangi kalÄ±nlÄ±k deÄŸeri kullanÄ±lÄ±r?", options: ["0", "1", "-1", "2", "255"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki konturlarÄ±n Ã§izim sÄ±rasÄ±nÄ± belirlemek iÃ§in hangi parametre kullanÄ±lÄ±r?", options: ["mode", "method", "hierarchy", "color", "order (contourIdx)"], correct: 4 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rmek iÃ§in Ã¶nce hangi iÅŸlem yapÄ±lÄ±r?", options: ["Transformasyon matrisi oluÅŸturulur", "GÃ¶rÃ¼ntÃ¼ kopyalanÄ±r", "Boyut deÄŸiÅŸtirilir", "Renk uzayÄ± deÄŸiÅŸtirilir", "Kenarlar bulunur"], correct: 0 },
            { q: "OpenCV'de iki gÃ¶rÃ¼ntÃ¼ arasÄ±ndaki mutlak farkÄ± hesaplamak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.diff()", "cv2.subtract()", "cv2.absdiff()", "cv2.compare()", "cv2.minus()"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki renk kanallarÄ±nÄ± birleÅŸtirmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.merge()", "cv2.combineChannels()", "cv2.stackChannels()", "cv2.join()", "cv2.channelMerge()"], correct: 0 },
            { q: "OpenCV'de iki gÃ¶rÃ¼ntÃ¼yÃ¼ yan yana birleÅŸtirmek iÃ§in hangi yÃ¶ntem uygundur?", options: ["np.hstack([img1, img2])", "np.vstack([img1, img2])", "cv2.merge(img1, img2)", "cv2.concat(img1, img2)", "cv2.combine(img1, img2)"], correct: 0 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n negatifini almak iÃ§in hangi iÅŸlem kullanÄ±lÄ±r?", options: ["cv2.bitwise_and()", "cv2.bitwise_or", "cv2.bitwise_xor()", "cv2.bitwise_not()", "cv2.negate()"], correct: 3 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n belirli bir bÃ¶lgesini bir maske kullanarak izole etmek veya sadece o bÃ¶lgeyi iÅŸlemek iÃ§in hangi iÅŸlem en yaygÄ±n ÅŸekilde kullanÄ±lÄ±r?", options: ["cv2.bitwise_or", "cv2.bitwise_not", "cv2.bitwise_xor", "cv2.bitwise_and", "cv2.bitwise_nand"], correct: 3 },
            { q: "cv2.bitwise_or(img1, img2) iÅŸlemi ne yapar?", options: ["GÃ¶rÃ¼ntÃ¼lerin kesiÅŸimini alÄ±r", "Piksel farkÄ±nÄ± alÄ±r", "GÃ¶rÃ¼ntÃ¼lerin birleÅŸimini alÄ±r", "Renk kanallarÄ±nÄ± deÄŸiÅŸtirir", "HistogramÄ± birleÅŸtirir"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n kontrastÄ±nÄ± otomatik olarak iyileÅŸtirmek iÃ§in kullanÄ±lan temel yÃ¶ntem hangisidir?", options: ["Medyan BulanÄ±klaÅŸtÄ±rma", "Histogram EÅŸitleme", "Canny Kenar Tespiti", "Sadece Bitwise AND iÅŸlemi", "AÅŸÄ±nma (Erosion)"], correct: 1 },
            { q: "GÃ¶rÃ¼ntÃ¼ histogramÄ±nÄ± yumuÅŸatmak iÃ§in hangi yÃ¶ntem kullanÄ±labilir?", options: ["Erosion", "Dilation", "Gaussian filtre", "Median filtre", "Bitwise iÅŸlem"], correct: 2 },
            { q: "Ä°ki gÃ¶rÃ¼ntÃ¼yÃ¼ belli oranlarda birbiriyle harmanlamak iÃ§in kullanÄ±lan ve saydamlÄ±k efekti veren fonksiyon hangisidir?", options: ["cv2.add()", "cv2.addWeighted()", "cv2.multiply()", "cv2.bitwise_or()", "cv2.resize()"], correct: 1 },
            { q: "OpenCV'de bir resmi kayÄ±psÄ±z sÄ±kÄ±ÅŸtÄ±rma yaparak kaydetmek iÃ§in hangi format uygundur?", options: ["PNG", "JPEG", "BMP", "GIF", "TIFF"], correct: 0 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼ye kenar algÄ±lama uygulamak iÃ§in hangi fonksiyon yaygÄ±ndÄ±r?", options: ["cv2.Canny(img, 100, 200)", "cv2.Sobel(img)", "cv2.Laplacian(img)", "cv2.GaussianBlur(img)", "cv2.filter2D(img)"], correct: 0 },
            { q: "GÃ¶rÃ¼ntÃ¼ye bulanÄ±klÄ±k efekti eklemek iÃ§in kullanÄ±lan yaygÄ±n OpenCV fonksiyonu hangisidir?", options: ["cv2.Canny", "cv2.erode()", "cv2.GaussianBlur()", "cv2.dilate()", "cv2.Sobel()"], correct: 2 },
            { q: "Python'da gÃ¶rÃ¼ntÃ¼deki gÃ¼rÃ¼ltÃ¼yÃ¼ azaltmak iÃ§in hangi filtre kullanÄ±lÄ±r?", options: ["Median filtre", "Laplacian filtre", "Sobel filtre", "Bilateral filtre", "Threshold filtre"], correct: 0 },
            { q: "cv2.Scharr operatÃ¶rÃ¼ cv2.Sobel operatÃ¶rÃ¼ne gÃ¶re hangi durumda tercih edilir?", options: ["Daha az iÅŸlem gÃ¼cÃ¼ gerektiÄŸinde", "Ã‡ekirdek boyutu 3x3 olduÄŸunda daha hassas kenar/gradyan bulmak iÃ§in", "BÃ¼yÃ¼k boyutlu resimlerde", "Renkli resimlerde", "Video iÅŸlerken"], correct: 1 },
            { q: "Canny Kenar Tespiti algoritmasÄ± temel olarak hangi bilgileri birleÅŸtirerek sonuÃ§ Ã¼retir?", options: ["Renkleri ve histogramlarÄ±", "Gauss filtresiyle gÃ¼rÃ¼ltÃ¼ azaltma, Sobel ile gradyan ve histerezis eÅŸikleme", "Sadece parlaklÄ±k deÄŸiÅŸimlerini", "Sadece kÄ±rmÄ±zÄ± kanal bilgilerini", "Morfolojik iÅŸlemleri"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki pikselleri renk benzerliklerine veya konumlarÄ±na gÃ¶re gruplayarak segmentasyon yapan algoritma hangisidir?", options: ["K-Means Clustering", "Canny Edge Detection", "Sobel Operator", "Erosion", "Template Matching"], correct: 0 },
            { q: "Kenar tespit algoritmalarÄ±ndan hangisi, kenarlarÄ±n yÃ¶nelimini de hesaplamak iÃ§in gradyan tÃ¼revlerini kullanÄ±r?", options: ["Medyan BulanÄ±klaÅŸtÄ±rma", "Sobel OperatÃ¶rÃ¼", "AÃ§Ä±lma (Opening)", "Hough Ã‡izgi Tespiti", "Morfolojik GeniÅŸletme"], correct: 1 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ bulanÄ±klaÅŸtÄ±rÄ±rken kenarlarÄ± korumak iÃ§in hangi filtre kullanÄ±lÄ±r?", options: ["Bilateral Filter", "GaussianBlur", "MedianBlur", "Average Blur", "Sobel"], correct: 0 },
            { q: "Kenar tespiti iÅŸlemlerinde yatay ve dikey tÃ¼revleri (gradyanlarÄ±) hesaplamak iÃ§in kullanÄ±lan fonksiyon hangisidir?", options: ["cv2.Sobel()", "cv2.Canny", "cv2.Laplacian()", "cv2.Scharr", "cv2.Deriv()"], correct: 0 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki gÃ¼rÃ¼ltÃ¼yÃ¼ azaltmak iÃ§in hangi filtre daha etkilidir?", options: ["Sobel", "Laplacian", "Median", "Canny", "Histogram"], correct: 2 },
            { q: "Sobel operatÃ¶rÃ¼ hangi amaÃ§la kullanÄ±lÄ±r?", options: ["Renk artÄ±rma", "GÃ¼rÃ¼ltÃ¼ giderme", "Kenar tespiti", "ParlaklÄ±k ayarlama", "DÃ¶ndÃ¼rme"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼de kenar bulmak iÃ§in kullanÄ±lan Sobel filtresinin yÃ¶nÃ¼ nasÄ±l belirlenir?", options: ["Kernel tÃ¼rÃ¼ne gÃ¶re", "EÅŸik deÄŸerine gÃ¶re", "dx ve dy parametrelerine gÃ¶re", "Kanal sayÄ±sÄ±na gÃ¶re", "Piksel tipine gÃ¶re"], correct: 2 },
            { q: "Kenar bulmak iÃ§in kullanÄ±lan Sobel operatÃ¶rÃ¼ hangi tÃ¼rev tÃ¼rÃ¼ne dayanÄ±r?", options: ["0. tÃ¼rev", "1. tÃ¼rev", "2. tÃ¼rev", "3. tÃ¼rev", "4. tÃ¼rev"], correct: 1 },
            { q: "GÃ¶rÃ¼ntÃ¼de dikey kenarlarÄ± tespit etmek iÃ§in Sobel operatÃ¶rÃ¼nde hangi kombinasyon kullanÄ±lÄ±r?", options: ["dx=0, dy=0", "dx=1, dy=1", "dx=1, dy=0", "dx=0, dy=2", "dx=2, dy=0"], correct: 2 },
            { q: "Ã–zel olarak oluÅŸturduÄŸunuz bir Kernel gÃ¶rÃ¼ntÃ¼ye uygulamak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.applyMask()", "cv2.customFilter()", "cv2.filter2D()", "cv2.convolve()", "cv2.matrixOp()"], correct: 2 },
            { q: "cv2.Scharr() fonksiyonu ne iÅŸe yarar?", options: ["Zoom yapar", "Renk deÄŸiÅŸtirir", "Daha hassas tÃ¼rev filtrelemesi yapar", "GÃ¼rÃ¼ltÃ¼ ekler", "GÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rÃ¼r"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼de gÃ¼rÃ¼ltÃ¼yÃ¼ azaltÄ±rken kenarlarÄ± daha iyi koruyan filtre hangisidir?", options: ["Mean filtre", "Box filtre", "Gaussian filtre", "Median filtre", "Bilateral filtre"], correct: 4 },
            { q: "cv2.convertScaleAbs genellikle hangi iÅŸlemde kullanÄ±lÄ±r?", options: ["Kanal ayÄ±rma", "GÃ¼rÃ¼ltÃ¼ ekleme", "Filtre sonrasÄ± deÄŸerleri 0-255 aralÄ±ÄŸÄ±na Ã§ekme (ve mutlak deÄŸer alma)", "MaskelenmiÅŸ bÃ¶lgeleri silme", "GÃ¶rÃ¼ntÃ¼yÃ¼ kÄ±rpma"], correct: 2 },
            { q: "cv2.bilateralFilter fonksiyonunun diÄŸer bulanÄ±klaÅŸtÄ±rma yÃ¶ntemlerinden en Ã¶nemli farkÄ± nedir?", options: ["Ã‡ok hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±dÄ±r", "Sadece siyah-beyaz resimlerde Ã§alÄ±ÅŸmasÄ±dÄ±r", "KenarlarÄ± koruyarak gÃ¼rÃ¼ltÃ¼yÃ¼ azaltmasÄ±dÄ±r", "GÃ¶rÃ¼ntÃ¼yÃ¼ keskinleÅŸtirmesidir", "GÃ¶rÃ¼ntÃ¼yÃ¼ ters Ã§evirmesidir"], correct: 2 },
            { q: "NumPy kullanarak bir resmi matris olarak okumak hangi avantajÄ± saÄŸlar?", options: ["Dosya boyutunu kÃ¼Ã§Ã¼ltÃ¼r", "Matematiksel iÅŸlemler ve filtreleri hÄ±zlÄ± uygulama", "Renkleri otomatik ayarlar", "Resmi ekranda gÃ¶sterir", "Resmi kaydeder"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki belirli bir bÃ¶lgeyi seÃ§mek iÃ§in hangi yÃ¶ntem kullanÄ±lÄ±r?", options: ["cv2.selectROI()", "cv2.regionSelect()", "cv2.maskArea()", "cv2.cropArea()", "cv2.areaSelect()"], correct: 0 },
            { q: "Python'da OpenCV ile yÃ¼z tanÄ±ma yaparken hangi dosya tipi kullanÄ±lÄ±r?", options: ["XML", "JSON", "TXT", "CSV", "YAML"], correct: 0 },
            { q: "OpenCV'de renkli gÃ¶rÃ¼ntÃ¼yÃ¼ gri tonlamaya Ã§evirirken hangi renk kanalÄ± daha fazla aÄŸÄ±rlÄ±k taÅŸÄ±r?", options: ["YeÅŸil", "KÄ±rmÄ±zÄ±", "Mavi", "Alfa", "TÃ¼m kanallar eÅŸit"], correct: 0 },
            { q: "img[100:200, 50:150] iÅŸlemi ne yapar?", options: ["GÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rÃ¼r", "GÃ¶rÃ¼ntÃ¼yÃ¼ yeniden boyutlandÄ±rÄ±r", "GÃ¶rÃ¼ntÃ¼yÃ¼ kesme yapar (Crop)", "GÃ¶rÃ¼ntÃ¼yÃ¼ siler", "GÃ¶rÃ¼ntÃ¼yÃ¼ Ã§evirir"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki belirli bir bÃ¶lgeyi siyah yapmak iÃ§in hangi kod kullanÄ±lÄ±r?", options: ["img[100:200, 100:200] = 0", "img[100:200, 100:200] = 255", "img[100:200, 100:200] = -1", "img[100:200, 100:200] = True", "img[100:200, 100:200] = None"], correct: 0 },
            { q: "cv2.polylines fonksiyonu ne Ã§izmek iÃ§in kullanÄ±lÄ±r?", options: ["Sadece dÃ¼z bir Ã§izgi", "Ã‡okgenler veya birbiri ardÄ±na eklenmiÅŸ Ã§izgiler", "Ã‡ember yaylarÄ±", "Elips", "NoktalÄ± Ä±zgara"], correct: 1 },
            { q: "Basit bir ÅŸeklin iÃ§ini doldurmak iÃ§in cv2.polylines yerine hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.drawPoly()", "cv2.fillPoly()", "cv2.paintPoly()", "cv2.solidPoly()", "cv2.areaPoly()"], correct: 1 },
            { q: "Hough Line Transform sonucunda Ã§izgiler genellikle hangi koordinat sisteminde ifade edilir?", options: ["Cartesian (x, y)", "Polar (r, theta)", "Complex (Real, Imaginary)", "3D (x, y, z)", "Logarithmic"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki nesneleri sÄ±nÄ±rlayan Ã§izgiyi bulmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.fitLine()", "cv2.drawLine()", "cv2.lineFit()", "cv2.findLine()", "cv2.minLine()"], correct: 0 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼ye Ã§izgi Ã§izmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.line()", "cv2.drawLine()", "cv2.plotLine()", "cv2.traceLine()", "cv2.lineDraw()"], correct: 0 },
            { q: "cv2.invert fonksiyonu matrisler Ã¼zerinde hangi matematiksel iÅŸlemi yapar?", options: ["Matrisin transpozunu alÄ±r", "Matrisin tersini alÄ±r", "Matrisin negatifini alÄ±r", "Matrisi sÄ±fÄ±rlar", "Matrisi birim matrise Ã§evirir"], correct: 1 },
            { q: "Bir matrisin transpozunu almak iÃ§in NumPy'da hangi sÃ¶z dizimi kullanÄ±lÄ±r?", options: ["img.T", "img.inverse()", "img.switch()", "img.rotate()", "img.change()"], correct: 0 },
            { q: "cv2.kmeans() algoritmasÄ± Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken criteria parametresi neyi belirtir?", options: ["KaÃ§ kÃ¼me oluÅŸturulacaÄŸÄ±nÄ±", "AlgoritmanÄ±n ne zaman duracaÄŸÄ±nÄ±", "BaÅŸlangÄ±Ã§ noktalarÄ±nÄ±n nasÄ±l seÃ§ileceÄŸini", "Renk uzayÄ±nÄ±", "Hata ayÄ±klama modunu"], correct: 1 },
            { q: "OpenCV'de gÃ¶rÃ¼ntÃ¼ bÃ¶lÃ¼tleme iÃ§in kullanÄ±lan fonksiyonlardan biri hangisidir?", options: ["cv2.segment()", "cv2.divideImage()", "cv2.kmeans()", "cv2.cut()", "cv2.clusterImage()"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼nÃ¼n ortanca piksel deÄŸerini bulmak iÃ§in kullanÄ±lan NumPy fonksiyonu hangisidir?", options: ["np.avg()", "np.median", "np.mean()", "np.middle()", "np.center()"], correct: 1 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼deki tÃ¼m piksellerin ortalama deÄŸerini almak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.mean()", "cv2.average()", "cv2.median()", "cv2.sum()", "cv2.mode()"], correct: 0 },
            { q: "Python'da iki gÃ¶rÃ¼ntÃ¼yÃ¼ yatay olarak birleÅŸtirmek iÃ§in hangi NumPy iÅŸlemi kullanÄ±labilir?", options: ["np.bind(img1, img2)", "np.attach(img1, img2)", "np.concatenate((img1, img2), axis=1)", "img1 + img2", "np.stack(img1, img2)"], correct: 2 },
            { q: "Gaussian gÃ¼rÃ¼ltÃ¼sÃ¼ Ã¼retmek iÃ§in kullanÄ±lan NumPy fonksiyonu hangisidir?", options: ["np.random.uniform()", "np.random.rand()", "np.random.normal()", "np.random.pixel()", "np.random.noise()"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼yÃ¼ tamamen sÄ±fÄ±rlarla doldurmak iÃ§in hangi NumPy yÃ¶ntemi kullanÄ±lÄ±r?", options: ["np.black()", "np.null()", "np.zeros()", "np.min()", "np.clear()"], correct: 2 },
            { q: "Python'da gÃ¶rÃ¼ntÃ¼nÃ¼n veri tipini float yapmak iÃ§in hangi NumPy ifadesi doÄŸrudur?", options: ["img.astype('float')", "img.type('float')", "img.toFloat()", "float(img)", "convert.float(img)"], correct: 0 },
            { q: "NumPy kÃ¼tÃ¼phanesi ne iÃ§in kullanÄ±lÄ±r?", options: ["Grafik Ã§izimi", "Web geliÅŸtirme", "SayÄ±sal hesaplamalar", "Dosya iÅŸlemleri", "Ses iÅŸleme"], correct: 2 },
            { q: "Python'da bir resmi NumPy dizisine Ã§evirdiÄŸimizde bu dizi hangi veri tipindedir?", options: ["list", "tuple", "ndarray", "dict", "set"], correct: 2 },
            { q: "Ä°ki gÃ¶rÃ¼ntÃ¼ arasÄ±ndaki mutlak farkÄ± hesaplayan fonksiyon hangisidir?", options: ["cv2.subtract()", "cv2.absdiff", "cv2.diff()", "cv2.minus()", "cv2.absolute()"], correct: 1 },
            { q: "np.mean(img) komutu bir gÃ¶rÃ¼ntÃ¼ iÃ§in ne dÃ¶ndÃ¼rÃ¼r?", options: ["Maximum piksel deÄŸeri", "Piksel sayÄ±sÄ±", "Ortalama piksel deÄŸeri", "Kanal sayÄ±sÄ±", "GÃ¶rÃ¼ntÃ¼ boyutu"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼deki maksimum piksel deÄŸerini bulmak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.max()", "np.max(img)", "img.max()", "cv2.findMax()", "max(img)"], correct: 1 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼nÃ¼n veya belirli bir bÃ¶lgesinin ortalamasÄ±nÄ± ve standart sapmasÄ±nÄ± aynÄ± anda hesaplamak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.calcStats()", "cv2.meanStdDev()", "cv2.average()", "cv2.stats()", "cv2.analyze()"], correct: 1 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼nÃ¼n veri tipini Ã¶ÄŸrenmek iÃ§in hangi Ã¶zellik kontrol edilir?", options: ["img.type", "img.dtype", "img.format", "img.bit", "img.class"], correct: 1 },
            { q: "OpenCV'de, bir gÃ¶rÃ¼ntÃ¼nÃ¼n sol Ã¼st kÃ¶ÅŸesinin koordinatlarÄ± nedir?", options: ["(1, 1)", "(GeniÅŸlik, YÃ¼kseklik)", "(0,0)", "(GeniÅŸlik, 0)", "(YÃ¼kseklik, GeniÅŸlik)"], correct: 2 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ saat yÃ¶nÃ¼nÃ¼n tersine 90 derece dÃ¶ndÃ¼rmek iÃ§in kullanÄ±labilecek cv2.rotate() parametresi hangisidir?", options: ["cv2.ROTATE_90_CLOCKWISE", "cv2.ROTATE_90_COUNTERCLOCKWISE", "cv2.ROTATE_180", "cv2.ROTATE_0", "cv2.ROTATE_270_CLOCKWISE"], correct: 1 },
            { q: "Hangisi dijital gÃ¶rÃ¼ntÃ¼ iÅŸleme adÄ±mlarÄ±ndan biri deÄŸildir?", options: ["Ã–n iÅŸleme", "DÃ¶nÃ¼ÅŸÃ¼m", "Ã–zellik Ã§Ä±karma", "Segmentasyon", "Derleyici optimizasyonu"], correct: 4 },
            { q: "np.clip(img, 0, 255) iÅŸlemi ne yapar?", options: ["Piksel deÄŸerlerini sÄ±fÄ±rlar", "Piksel deÄŸerlerini ters Ã§evirir", "Piksel deÄŸerlerini 0-255 aralÄ±ÄŸÄ±nda sÄ±nÄ±rlar", "GÃ¶rÃ¼ntÃ¼yÃ¼ kÃ¼Ã§Ã¼ltÃ¼r", "GÃ¶rÃ¼ntÃ¼yÃ¼ dÃ¶ndÃ¼rÃ¼r"], correct: 2 },
            { q: "img.size ifadesi bir gÃ¶rÃ¼ntÃ¼ hakkÄ±nda neyi verir?", options: ["Boyut (yÃ¼kseklik, geniÅŸlik)", "Kanal sayÄ±sÄ±", "Toplam piksel sayÄ±sÄ±", "Veri tipi", "Dosya boyutu"], correct: 2 },
            { q: "LAB renk uzayÄ±ndaki 'L' bileÅŸeni neyi temsil eder?", options: ["ParlaklÄ±k yoÄŸunluÄŸunu (Lightness)", "Seviye deÄŸerini", "DÃ¼ÅŸÃ¼k frekanslarÄ±", "Laboratuvar standartlarÄ±nÄ±", "Katman sayÄ±sÄ±nÄ±"], correct: 0 },
            { q: "Makine Ã¶ÄŸrenme algoritmalarÄ±nÄ± kullanmak iÃ§in hangi OpenCV modÃ¼lÃ¼ kullanÄ±lÄ±r?", options: ["cv2.ai", "cv2.learning", "cv2.ml", "cv2.svm", "cv2.data"], correct: 2 },
            { q: "Gaussian bulanÄ±klaÅŸtÄ±rmada kernel boyutu iÃ§in hangi Ã¶zellik doÄŸrudur?", options: ["Tek sayÄ±lar olmalÄ±dÄ±r", "Ã‡ift sayÄ±lar olmalÄ±dÄ±r", "SÄ±fÄ±r olmalÄ±dÄ±r", "Her zaman 3'tÃ¼r", "Ã–nemli deÄŸildir"], correct: 0 },
            { q: "Python'da OpenCV ile resim Ã¼zerinde Ã§izgi Ã§izmek iÃ§in hangi parametreler zorunludur?", options: ["BaÅŸlangÄ±Ã§ ve bitiÅŸ koordinatlarÄ±, renk, kalÄ±nlÄ±k", "BaÅŸlangÄ±Ã§ koordinatÄ± ve renk", "Bitis koordinatÄ± ve renk", "KalÄ±nlÄ±k ve renk", "Koordinat ve sigma"], correct: 0 },
            { q: "Python'da NumPy kÃ¼tÃ¼phanesini iÃ§e aktarmak iÃ§in hangi kod kullanÄ±lÄ±r?", options: ["import numpy", "import numpy as np", "from numpy import", "include numpy", "using numpy"], correct: 1 },
            { q: "Gri tonlamalÄ± bir gÃ¶rÃ¼ntÃ¼yÃ¼, sÄ±caklÄ±k haritasÄ± gibi renklendirmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.cvtColor()", "cv2.applyColorMap()", "cv2.colorize()", "cv2.heatMap()", "cv2.pseudoColor()"], correct: 1 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ HSV formatÄ±ndan BGR formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in hangi ifade kullanÄ±lÄ±r?", options: ["cv2.cvtColor(img, cv2.COLOR_BGR2HSV)", "cv2.cvtColor(img, cv2.COLOR_RGB2HSV)", "cv2.cvtColor(img, cv2.COLOR_HSV2BGR)", "cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)", "cv2.cvtColor(img, cv2.COLOR_HSV2GRAY)"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼deki renk uzayÄ±nÄ± deÄŸiÅŸtirmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.cvtColor()", "cv2.changeColor()", "cv2.convertColor()", "cv2.colorTransform()", "cv2.colorSpace()"], correct: 0 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ BGR'den RGB'ye Ã§evirmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.cvtColor(img, cv2.COLOR_BGR2RGB)", "cv2.toRGB(img)", "cv2.changeColor(img)", "cv2.shiftColor(img)", "cv2.convert(img)"], correct: 0 },
            { q: "Python'da renkli bir resmi gri tonlamaya Ã§evirmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.toGray(img)", "cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)", "cv2.gray(img)", "cv2.cvtGray(img)", "cv2.transform(img, cv2.GRAY)"], correct: 1 },
            { q: "Bir NumPy dizisinin boyutlarÄ±nÄ± Ã¶ÄŸrenmek iÃ§in hangi Ã¶zellik kullanÄ±lÄ±r?", options: ["array.size", "array.dimension", "array.shape", "array.length", "array.dims"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼yÃ¼ okuyan cv2.imread fonksiyonu hangi deÄŸeri dÃ¶ndÃ¼rÃ¼r?", options: ["String", "List", "NumPy array", "Tuple", "Dictionary"], correct: 2 },
            { q: "Python'da bir gÃ¶rÃ¼ntÃ¼nÃ¼n piksel deÄŸerlerini matris olarak tutmak iÃ§in en Ã§ok hangi veri yapÄ±sÄ± kullanÄ±lÄ±r?", options: ["dictionary", "list", "numpy array", "tuple", "set"], correct: 2 },
            { q: "Matplotlib kÃ¼tÃ¼phanesinde bir gÃ¶rÃ¼ntÃ¼yÃ¼ gÃ¶stermek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["plt.show()", "plt.display()", "plt.view()", "plt.render", "plt.present()"], correct: 0 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼nÃ¼n geniÅŸlik ve yÃ¼kseklik bilgisine nasÄ±l eriÅŸilir?", options: ["image.width, image.height", "image.shape[0], image.shape[1]", "image.shape[1], image.shape[0] (w,h)", "image.size[0], image.size[1]", "image.dimensions()"], correct: 2 },
            { q: "OpenCV'de bir gÃ¶rÃ¼ntÃ¼yÃ¼ kaydetmek iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.save()", "cv2.write()", "cv2.imwrite()", "cv2.saveImage()", "cv2.export"], correct: 2 },
            { q: "GÃ¶rÃ¼ntÃ¼ histogramÄ± Ã§iziminde hangi matplotlib fonksiyonu kullanÄ±lÄ±r?", options: ["plt.hist()", "plt.plot()", "plt.imshow()", "plt.bar()", "plt.draw()"], correct: 0 },
            { q: "plt.hist() fonksiyonunda histogram Ã§ubuklarÄ±nÄ±n sayÄ±sÄ±nÄ± belirleyen parametre hangisidir?", options: ["bars", "bins", "columns", "count", "segments"], correct: 1 },
            { q: "plt.hist() fonksiyonunda histogram rengini belirlemek iÃ§in hangi parametre kullanÄ±lÄ±r?", options: ["colour", "col", "color", "rgb", "fill"], correct: 2 },
            { q: "plt.hist() fonksiyonunda histogramÄ±n kenar Ã§izgisi rengini ayarlamak iÃ§in hangi parametre kullanÄ±lÄ±r?", options: ["border", "edge", "edgecolor", "linecolor", "outline"], correct: 2 },
            { q: "plt.tight_layout() fonksiyonunun amacÄ± nedir?", options: ["GrafiÄŸi sÄ±kÄ±ÅŸtÄ±rÄ±r", "Alt grafiklerin birbirine girmesini Ã¶nler", "Grafik boyutunu kÃ¼Ã§Ã¼ltÃ¼r", "Grafik renklerini optimize eder", "Ã‡izim hÄ±zÄ±nÄ± artÄ±rÄ±r"], correct: 1 },
            { q: "Histogram grafiklerini tek figÃ¼rde yan yana gÃ¶stermek iÃ§in Matplotlib'de hangi komut kullanÄ±lÄ±r?", options: ["plt.show()", "plt.grid()", "plt.subplots()", "plt.canvas()", "plt.multi()"], correct: 2 },
            { q: "Matplotlib'de birden fazla alt grafik oluÅŸtururken hangi fonksiyon kullanÄ±lÄ±r?", options: ["plt.subgraph()", "plt.subplot()", "plt.multiplot()", "plt.subwindow()", "plt.divide()"], correct: 1 },
            { q: "cv2.resize() fonksiyonunda yeni boyut hangi parametre ile belirtilir?", options: ["size", "dimensions", "dsize", "newsize", "scale"], correct: 2 },
            { q: "Tespit edilen bir konturun alanÄ±nÄ± piksel cinsinden hesaplamak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.contourArea()", "cv2.calcArea()", "cv2.getArea()", "cv2.findSize()", "cv2.polyArea()"], correct: 0 },
            { q: "Bir konturun etrafÄ±nÄ± Ã§evreleyen Ã§izginin toplam uzunluÄŸunu hesaplamak iÃ§in hangi fonksiyon kullanÄ±lÄ±r?", options: ["cv2.contourArea()", "cv2.arcLength()", "cv2.getPerimeter()", "cv2.contourLength()", "cv2.calculateCircumference"], correct: 1 },
            { q: "cv2.resize fonksiyonunda en yakÄ±n komÅŸu interpolasyonu iÃ§in hangi sabit kullanÄ±lÄ±r?", options: ["cv2.INTER_NEAREST", "cv2.NEAREST", "cv2.INTER_NEIGHBOR", "cv2.INTERPOLATE_NEAREST", "cv2.NEAR"], correct: 0 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ yeniden boyutlandÄ±rÄ±rken, gÃ¶rÃ¼ntÃ¼nÃ¼n kalitesini koruyarak kÃ¼Ã§Ã¼ltmek iÃ§in Ã¶nerilen interpolasyon yÃ¶ntemi hangisidir?", options: ["cv2.INTER_NEAREST", "cv2.INTER_LINEAR", "cv2.INTER_CUBIC", "cv2.INTER_AREA", "cv2.INTER_MAX"], correct: 3 },
            { q: "Bir gÃ¶rÃ¼ntÃ¼yÃ¼ yeniden boyutlandÄ±rÄ±rken, gÃ¶rÃ¼ntÃ¼nÃ¼n kalitesini koruyarak bÃ¼yÃ¼tmek iÃ§in genellikle hangi interpolasyon yÃ¶ntemi Ã¶nerilir?", options: ["cv2.INTER_NEAREST", "cv2.INTER_AREA", "cv2.INTER_CUBIC", "cv2.INTER_MAX", "cv2.INTER_MIN"], correct: 2 },
            { q: "cv2.resize fonksiyonunda cv2.INTER_LINEAR interpolasyon yÃ¶ntemi ne amaÃ§la kullanÄ±lÄ±r?", options: ["En dÃ¼ÅŸÃ¼k kalite ve en hÄ±zlÄ± yeniden boyutlandÄ±rma", "VarsayÄ±lan interpolasyon yÃ¶ntemidir ve bÃ¼yÃ¼tme/kÃ¼Ã§Ã¼ltmede makul bir kalite sunar", "Sadece kÃ¼Ã§Ã¼ltme iÃ§in kullanÄ±lÄ±r", "Sadece bÃ¼yÃ¼tme iÃ§in kullanÄ±lÄ±r", "Sadece Medyan filtrelemesi yapar"], correct: 1 },
            { q: "cv2.resize fonksiyonunda yeniden boyutlandÄ±rma algoritmasÄ±nÄ± belirten interpolation parametresi iÃ§in aÅŸaÄŸÄ±dakilerden hangisi bir seÃ§enek deÄŸildir?", options: ["cv2.INTER_LINEAR", "cv2.INTER_CUBIC", "cv2.INTER_AREA", "cv2.INTER_NEAREST", "cv2.INTER_FAST"], correct: 4 }
        ];

        // --- APP STATE ---
        let currentQuestions = [];
        let currentIndex = 0;
        let score = 0;
        let wrongAnswers = [];
        let userAnswers = []; // KullanÄ±cÄ±nÄ±n cevaplarÄ±nÄ± tutar
        let checkedAnswers = []; // CevaplarÄ±n kontrol edilip edilmediÄŸini tutar
        let isReviewMode = false;

        // --- DOM ELEMENTS ---
        const questionText = document.getElementById("question-text");
        const optionsList = document.getElementById("options-list");
        const checkBtn = document.getElementById("check-btn");
        const nextBtn = document.getElementById("next-btn");
        const prevBtn = document.getElementById("prev-btn");
        const counterText = document.getElementById("question-counter");
        const progressFill = document.getElementById("progress-fill");
        const quizArea = document.getElementById("quiz-area");
        const resultArea = document.getElementById("result-area");
        const questionJumpInput = document.getElementById("question-jump-input");
        const questionJumpBtn = document.getElementById("question-jump-btn");
        
        // --- EVENT LISTENERS ---
        questionJumpBtn.addEventListener('click', jumpToQuestion);
        questionJumpInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                jumpToQuestion();
            }
        });

        // --- INITIALIZATION ---
        function initQuiz(questions) {
            currentQuestions = questions;
            currentIndex = 0;
            score = 0;
            wrongAnswers = [];
            userAnswers = new Array(questions.length).fill(null);
            checkedAnswers = new Array(questions.length).fill(false);

            quizArea.style.display = "block";
            resultArea.style.display = "none";
            
            loadQuestion();
        }

        function jumpToQuestion() {
            const num = parseInt(questionJumpInput.value, 10);
            if (num && num >= 1 && num <= currentQuestions.length) {
                currentIndex = num - 1;
                loadQuestion();
                questionJumpInput.value = ''; // Clear input
            } else {
                alert(`LÃ¼tfen 1 ile ${currentQuestions.length} arasÄ±nda geÃ§erli bir soru numarasÄ± girin.`);
            }
        }

        function loadQuestion() {
            // ButonlarÄ± ve seÃ§enekleri sÄ±fÄ±rla
            nextBtn.style.display = "none";
            checkBtn.style.display = "none";
            prevBtn.style.display = currentIndex > 0 ? "inline-block" : "none";
            optionsList.innerHTML = "";
            
            const currentQ = currentQuestions[currentIndex];
            
            // Soru metnini ve ilerleme Ã§ubuÄŸunu gÃ¼ncelle
            questionText.textContent = `${currentIndex + 1}. ${currentQ.q}`;
            counterText.textContent = `Soru ${currentIndex + 1} / ${currentQuestions.length}`;
            const progressPct = ((currentIndex) / currentQuestions.length) * 100;
            progressFill.style.width = `${progressPct}%`;

            // SeÃ§enekleri oluÅŸtur
            currentQ.options.forEach((opt, index) => {
                const li = document.createElement("li");
                li.className = "option-item";
                li.textContent = opt;
                li.onclick = () => selectOption(index, li);
                optionsList.appendChild(li);
            });

            const items = document.querySelectorAll(".option-item");

            // EÄŸer bu soru daha Ã¶nce cevaplandÄ±ysa, durumu yeniden yÃ¼kle
            if (checkedAnswers[currentIndex]) {
                const userAnswer = userAnswers[currentIndex];
                items[userAnswer.selected].classList.add(userAnswer.isCorrect ? "correct" : "wrong");
                if (!userAnswer.isCorrect) {
                    items[currentQ.correct].classList.add("correct");
                }
                items.forEach(item => item.style.pointerEvents = "none"); // Tekrar seÃ§im yapmayÄ± engelle
                nextBtn.style.display = "inline-block";
            } 
            // CevaplanmadÄ±ysa ama bir seÃ§im yapÄ±lÄ±p geri dÃ¶nÃ¼ldÃ¼yse
            else if (userAnswers[currentIndex] !== null) {
                const selectedIdx = userAnswers[currentIndex].selected;
                items[selectedIdx].classList.add("selected");
                checkBtn.style.display = "inline-block";
            }
        }

        function selectOption(index, element) {
            if (checkedAnswers[currentIndex]) return; // Cevap kontrol edildiyse seÃ§im yapmayÄ± engelle

            const items = document.querySelectorAll(".option-item");
            items.forEach(item => item.classList.remove("selected"));
            element.classList.add("selected");
            
            userAnswers[currentIndex] = { selected: index };
            checkBtn.style.display = "inline-block";
        }

        function checkAnswer() {
            const userAnswer = userAnswers[currentIndex];
            if (userAnswer === null) return;
            
            checkedAnswers[currentIndex] = true;
            const currentQ = currentQuestions[currentIndex];
            const isCorrect = userAnswer.selected === currentQ.correct;
            userAnswer.isCorrect = isCorrect;

            const items = document.querySelectorAll(".option-item");
            items.forEach(item => item.style.pointerEvents = "none");
            checkBtn.style.display = "none";
            nextBtn.style.display = "inline-block";

            if (isCorrect) {
                items[userAnswer.selected].classList.add("correct");
                items[userAnswer.selected].innerHTML += ` <span style="float:right;">âœ…</span>`;
                score++;
            } else {
                items[userAnswer.selected].classList.add("wrong");
                items[userAnswer.selected].innerHTML += ` <span style="float:right;">âŒ</span>`;
                items[currentQ.correct].classList.add("correct");
                items[currentQ.correct].innerHTML += ` <span style="float:right; font-size:0.9em;">(DoÄŸru Cevap)</span>`;
                
                // HatalÄ± cevaplarÄ± tekrar Ã§Ã¶zme modu iÃ§in ekle
                if (!wrongAnswers.some(q => q.q === currentQ.q)) {
                    wrongAnswers.push(currentQ);
                }
            }
        }

        function previousQuestion() {
            if (currentIndex > 0) {
                currentIndex--;
                loadQuestion();
            }
        }

        function nextQuestion() {
            currentIndex++;
            if (currentIndex < currentQuestions.length) {
                loadQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            quizArea.style.display = "none";
            resultArea.style.display = "block";
            
            progressFill.style.width = "100%";
            counterText.textContent = "TamamlandÄ±";

            const finalScore = userAnswers.filter(a => a && a.isCorrect).length;
            const totalAnswered = userAnswers.filter(a => a !== null).length;

            const percentage = Math.round((finalScore / currentQuestions.length) * 100);
            document.getElementById("final-score").textContent = `%${percentage}`;
            document.getElementById("total-correct").textContent = finalScore;
            document.getElementById("total-wrong").textContent = currentQuestions.length - finalScore;

            const circle = document.getElementById("score-circle");
            const color = percentage >= 50 ? "var(--success-color)" : "var(--error-color)";
            circle.style.background = `conic-gradient(${color} ${percentage}%, var(--border-color) 0)`;

            const fbText = document.getElementById("feedback-text");
            if(percentage >= 90) fbText.textContent = "MÃ¼kemmel! Neredeyse hatasÄ±z. ğŸ†";
            else if(percentage >= 70) fbText.textContent = "Gayet iyi gidiyorsun! ğŸš€";
            else if(percentage >= 50) fbText.textContent = "Fena deÄŸil, biraz tekrarla sÃ¼per olur. ğŸ“š";
            else fbText.textContent = "Daha fazla Ã§alÄ±ÅŸmalÄ±sÄ±n. Pes etmek yok! ğŸ’ª";

            const retryBtn = document.getElementById("retry-wrong-btn");
            const finalWrongAnswers = currentQuestions.filter((q, i) => userAnswers[i] && !userAnswers[i].isCorrect);

            if (finalWrongAnswers.length > 0) {
                retryBtn.style.display = "inline-block";
                retryBtn.textContent = `HatalÄ± ${finalWrongAnswers.length} Soruyu Ã‡Ã¶z`;
                // Global wrongAnswers listesini final sonuÃ§la gÃ¼ncelle
                wrongAnswers = finalWrongAnswers; 
            } else {
                retryBtn.style.display = "none";
            }
        }

        function restartFullQuiz() {
            isReviewMode = false;
            initQuiz(fullQuestionPool);
        }

        function retryWrongAnswers() {
            isReviewMode = true;
            const questionsToRetry = [...wrongAnswers];
            initQuiz(questionsToRetry);
        }


        function toggleDarkMode() {
            document.body.classList.toggle("dark-mode");
        }

        // UygulamayÄ± baÅŸlat
        initQuiz(fullQuestionPool);

    </script>
</body>
</html>